<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>가속도계 데이터 분석</title>
    
    <link rel="stylesheet" href="../css/style.css">
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/regression/2.0.1/regression.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
</head>
<body>
    <div class="container">
        <a href="../index.html">&laquo; 메인 페이지로 돌아가기</a>
        <h1>가속도계 데이터 분석</h1>
        <p>상태: <span id="status">연결 대기</span></p>

        <div class="connection-section">
            <h3>연결 방식 선택</h3>
            <button id="collisionSimButton" class="sim-button">1. 자동차 충돌 시뮬레이션 시작</button>
            <hr>
            <button id="connectBleButton" class="ble-button">1. 아두이노(BLE) 연결</button>
        </div>

        <div class="simulation-area">
            <div class="car" id="simCar">CAR</div>
            <div class="explosion" id="simExplosion"></div>
            <div class="wall"></div>
        </div>

        <div class="button-group">
            <button id="recordButton" disabled>2. 측정 시작</button>
            <select id="samplingRateSelect">
                <option value="10">10ms (100 Hz)</option>
                <option value="100">100ms (10 Hz)</option>
                <option value="500">500ms (2 Hz)</option>
                <option value="1000" selected>1s (1 Hz)</option>
                <option value="2000">2s (0.5 Hz)</option>
            </select>
            <button id="downloadButton" disabled>3. 엑셀 저장</button>
        </div>
        
        <div class="main-layout">
            <div class="content-column">
                <h2>측정 기록</h2>
                <div class="table-container">
                    <table id="historyTable">
                        <thead>
                            <tr>
                                <th>Timestamp</th><th>X</th><th>Y</th><th>Z</th>
                            </tr>
                        </thead>
                        <tbody id="historyTbody"></tbody>
                    </table>
                </div>
            </div>

            <div class="content-column">
                <h2>그래프 시각화 및 함수 피팅</h2>
                
                <div class="chart-wrapper">
                    <div class="chart-container"><canvas id="myChart"></canvas></div>
                    <div id="range-slider" style="display:none;"></div>
                </div>

                <div class="graph-controls">
                    <span>X축:</span>
                    <select id="xAxisSelect"><option value="Index">데이터 순서 (Index)</option><option value="X">X</option><option value="Y">Y</option><option value="Z">Z</option></select>
                    <span>Y축:</span>
                    <select id="yAxisSelect"><option value="X">X</option><option value="Y">Y</option><option value="Z">Z</option></select>
                    <button id="resetZoomButton">줌 리셋</button>
                </div>
                 <div class="graph-controls fit-controls">
                    <span>피팅 범위: <b id="range-value"></b></span>
                    <select id="polynomialOrderSelect" style="margin-left: auto;">
                        <option value="1">1차</option><option value="2">2차</option><option value="3" selected>3차</option>
                    </select>
                    <button id="fitButton" disabled>함수 피팅</button>
                </div>

                <div class="fit-result">
                    <p>피팅 방정식: <span id="equation"></span></p>
                    <p><b>결정계수 (R²): <span id="r2_value"></span></b></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. UI 요소 및 전역 변수 선언 ---
        const connectBleButton = document.getElementById('connectBleButton');
        const collisionSimButton = document.getElementById('collisionSimButton'); // 새롭게 추가
        const recordButton = document.getElementById('recordButton');
        const downloadButton = document.getElementById('downloadButton');
        const fitButton = document.getElementById('fitButton');
        const statusSpan = document.getElementById('status');
        const equationSpan = document.getElementById('equation');
        const r2ValueSpan = document.getElementById('r2_value');
        const historyTbody = document.getElementById('historyTbody');
        const xAxisSelect = document.getElementById('xAxisSelect');
        const yAxisSelect = document.getElementById('yAxisSelect');
        const samplingRateSelect = document.getElementById('samplingRateSelect');
        const resetZoomButton = document.getElementById('resetZoomButton');
        const chartCanvas = document.getElementById('myChart');
        const polynomialOrderSelect = document.getElementById('polynomialOrderSelect');
        const rangeSlider = document.getElementById('range-slider');
        const rangeValue = document.getElementById('range-value');

        // 애니메이션 관련 요소 추가
        const simCar = document.getElementById('simCar');
        const simExplosion = document.getElementById('simExplosion');

        let recordedData = []; 
        let isRecording = false;
        let collisionSimulationInterval; // 시뮬레이션 인터벌 변수
        let samplingIntervalMs = 100; // 시뮬레이션은 좀 더 빠르게 데이터를 생성
        let lastSampleTime = 0;
        let myChart;
        let lastGraphUpdateTime = 0;

        const UART_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
        const UART_TX_CHAR_UUID = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";

        // --- 2. 차트 초기화 ---
        myChart = new Chart(chartCanvas, {
            type: 'scatter',
            data: { datasets: [{ label: '원본 데이터', data: [], backgroundColor: 'rgba(75, 192, 192, 0.6)', pointRadius: 3 }, { label: '함수 피팅', data: [], borderColor: 'rgba(255, 99, 132, 1)', type: 'line', fill: false, tension: 0.1, pointRadius: 0 }] },
            options: {
                responsive: true, maintainAspectRatio: false, 
                scales: { x: { type: 'linear', title: { display: true, text: 'X-Axis' } }, y: { title: { display: true, text: 'Y-Axis' } } },
                plugins: {
                    zoom: { pan: { enabled: true, mode: 'xy' }, zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy' } },
                    annotation: {
                        annotations: {
                            startLine: { type: 'line', scaleID: 'x', value: 0, borderColor: 'rgba(255, 99, 132, 0.8)', borderWidth: 2, borderDash: [6, 6], display: false },
                            endLine: { type: 'line', scaleID: 'x', value: 0, borderColor: 'rgba(255, 99, 132, 0.8)', borderWidth: 2, borderDash: [6, 6], display: false }
                        }
                    }
                }
            }
        });

        // --- 3. 이벤트 리스너 연결 ---

        // 가상 충돌 시뮬레이션 버튼 이벤트
        collisionSimButton.addEventListener('click', () => {
            statusSpan.textContent = "자동차 충돌 시뮬레이션 시작";
            connectBleButton.disabled = true;
            collisionSimButton.disabled = true;
            recordButton.disabled = false;
            
            // 시뮬레이션 시작
            startCollisionSimulation();
        });

        connectBleButton.addEventListener('click', async () => { 
            // BLE 연결 시뮬레이션 중지
            if (collisionSimulationInterval) {
                clearInterval(collisionSimulationInterval);
                simCar.style.transform = `translateX(0px)`; // 자동차 초기 위치로
                simExplosion.classList.remove('active');
                statusSpan.textContent = 'BLE 연결 대기';
            }
            // 기존 BLE 연결 로직
            try { 
                const device = await navigator.bluetooth.requestDevice({ filters: [{ namePrefix: 'Sensor-' }], optionalServices: [UART_SERVICE_UUID] }); 
                statusSpan.textContent = `연결 중: ${device.name}`; 
                const server = await device.gatt.connect(); 
                const service = await server.getPrimaryService(UART_SERVICE_UUID); 
                const characteristic = await server.getCharacteristic(UART_TX_CHAR_UUID); 
                await characteristic.startNotifications(); 
                characteristic.addEventListener('characteristicvaluechanged', handleBleNotifications); 
                statusSpan.textContent = `연결됨: ${device.name}`; 
                connectBleButton.disabled = true; 
                collisionSimButton.disabled = true; // BLE 연결 시 시뮬레이션 버튼 비활성화
                recordButton.disabled = false; 
            } catch (error) { 
                console.error('BLE 연결 실패:', error); 
                statusSpan.textContent = 'BLE 연결 실패'; 
                collisionSimButton.disabled = false; // 실패 시 시뮬레이션 버튼 다시 활성화
            } 
        });

        samplingRateSelect.addEventListener('change', (event) => { samplingIntervalMs = parseInt(event.target.value); });
        
        recordButton.addEventListener('click', () => {
            isRecording = !isRecording;
            if (isRecording) {
                lastSampleTime = 0; recordedData = []; historyTbody.innerHTML = ''; 
                myChart.data.datasets[0].data = []; myChart.data.datasets[1].data = []; myChart.update('none');
                equationSpan.textContent = ''; r2ValueSpan.textContent = ''; 
                recordButton.textContent = '측정 중지'; recordButton.style.backgroundColor = '#DC3545'; 
                downloadButton.disabled = true; fitButton.disabled = true;
                rangeSlider.style.display = 'none';
                if (rangeSlider.noUiSlider) { rangeSlider.noUiSlider.destroy(); }
                statusSpan.textContent = '측정 중...';
            } else {
                recordButton.textContent = '측정 시작'; recordButton.style.backgroundColor = '#28A745'; statusSpan.textContent = '측정 완료';
                if (recordedData.length > 0) { 
                    downloadButton.disabled = false; fitButton.disabled = false;
                    createOrUpdateSlider(); 
                }
            }
        });
        
        resetZoomButton.addEventListener('click', () => myChart.resetZoom());
        fitButton.addEventListener('click', fitPolynomialToRange);
        downloadButton.addEventListener('click', downloadSelectedData);
        xAxisSelect.addEventListener('change', () => { updateGraphAxes(); if(rangeSlider.noUiSlider) createOrUpdateSlider(); });
        yAxisSelect.addEventListener('change', updateGraphAxes);
        
        // --- 4. 함수 정의 ---

        // BLE 데이터 처리 (기존과 동일)
        function onDataReceived(x, y, z) { const now = Date.now(); if (now - lastSampleTime >= samplingIntervalMs) { lastSampleTime = now; processAndDisplayData(x, y, z); } }
        function handleBleNotifications(event) { const value = event.target.value; const decoder = new TextDecoder('utf-8'); const dataString = decoder.decode(value); const [x, y, z] = dataString.split(','); onDataReceived(x, y, z); }
        
        function processAndDisplayData(x, y, z) {
            if (isRecording) {
                const timestamp = new Date().toISOString();
                const currentData = [timestamp, parseFloat(x), parseFloat(y), parseFloat(z)];
                recordedData.push(currentData);
                const newRow = historyTbody.insertRow(0);
                newRow.innerHTML = `<td>${currentData[0]}</td><td>${currentData[1].toFixed(4)}</td><td>${currentData[2].toFixed(4)}</td><td>${currentData[3].toFixed(4)}</td>`;
                updateGraphAxes();
            }
        }
        
        function updateGraphAxes() {
            const colMap = { 'Index': -1, 'X': 1, 'Y': 2, 'Z': 3 };
            const xAxisColumn = xAxisSelect.value;
            const yAxisColumn = yAxisSelect.value;
            const xIndex = colMap[xAxisColumn];
            const yIndex = colMap[yAxisColumn];
            const scatterData = recordedData.map((row, i) => ({ x: (xIndex === -1) ? i : row[xIndex], y: row[yIndex] }));
            myChart.data.datasets[0].data = scatterData;
            myChart.options.scales.x.title.text = xAxisColumn;
            myChart.options.scales.y.title.text = yAxisColumn;
            const now = Date.now();
            if (now - lastGraphUpdateTime > 200) { myChart.update('none'); lastGraphUpdateTime = now; }
        }

        function alignSliderWithChart() {
            if (!myChart || !rangeSlider.parentElement) return;
            const chartArea = myChart.chartArea;
            if (!chartArea) return;
            rangeSlider.style.left = `${chartArea.left}px`;
            rangeSlider.style.width = `${chartArea.width}px`;
            rangeSlider.style.bottom = `${myChart.height - chartArea.bottom}px`;
        }
        new ResizeObserver(alignSliderWithChart).observe(chartCanvas);

        function createOrUpdateSlider() {
            const colMap = { 'Index': -1, 'X': 1, 'Y': 2, 'Z': 3 }, xAxisColumn = xAxisSelect.value, xIndex = colMap[xAxisColumn];
            const xData = recordedData.map((row, i) => (xIndex === -1) ? i : row[xIndex]);
            const minX = xData.length > 0 ? Math.min(...xData) : 0;
            const maxX = xData.length > 0 ? Math.max(...xData) : 1;
            
            rangeSlider.style.display = 'block';
            if (rangeSlider.noUiSlider) {
                rangeSlider.noUiSlider.updateOptions({ range: { 'min': minX, 'max': maxX }, start: [minX, maxX] });
            } else {
                noUiSlider.create(rangeSlider, { start: [minX, maxX], connect: true, range: { 'min': minX, 'max': maxX } });
            }
            rangeSlider.noUiSlider.on('update', (values) => {
                const startVal = parseFloat(values[0]);
                const endVal = parseFloat(values[1]);
                rangeValue.textContent = `${startVal.toFixed(2)} ~ ${endVal.toFixed(2)}`;
                myChart.options.plugins.annotation.annotations.startLine.value = startVal;
                myChart.options.plugins.annotation.annotations.startLine.display = true;
                myChart.options.plugins.annotation.annotations.endLine.value = endVal;
                myChart.options.plugins.annotation.annotations.endLine.display = true;
                myChart.update('none');
            });
            alignSliderWithChart();
        }

        function fitPolynomialToRange() {
            if (!rangeSlider.noUiSlider) { alert('먼저 데이터를 측정해주세요.'); return; }
            const order = parseInt(polynomialOrderSelect.value);
            const [startStr, endStr] = rangeSlider.noUiSlider.get();
            const startX = parseFloat(startStr);
            const endX = parseFloat(endStr);
            if (startX >= endX) { alert("유효한 범위를 선택해주세요."); return; }
            
            const colMap = { 'Index': -1, 'X': 1, 'Y': 2, 'Z': 3 };
            const xAxisColumn = xAxisSelect.value;
            const yAxisColumn = yAxisSelect.value;
            const xIndex = colMap[xAxisColumn];
            const yIndex = colMap[yAxisColumn];
            const dataForFitting = recordedData.map((row, i) => {
                const xValue = (xIndex === -1) ? i : row[xIndex];
                return [xValue, row[yIndex]];
            }).filter(point => point[0] >= startX && point[0] <= endX);
            
            if (dataForFitting.length < order + 1) { alert(`${order}차 함수 피팅을 위해서는 최소 ${order + 1}개의 데이터가 범위 내에 있어야 합니다. (현재 ${dataForFitting.length}개)`); return; }
            
            const result = regression.polynomial(dataForFitting, { order: order, precision: 5 });
            equationSpan.textContent = result.string;
            r2ValueSpan.textContent = result.r2.toFixed(4);
            const fittedPoints = result.points.map(p => ({x: p[0], y: p[1]}));
            myChart.data.datasets[1].data = fittedPoints;
            myChart.data.datasets[1].label = `${order}차 피팅 (R²=${result.r2.toFixed(4)})`;
            myChart.update();
        }

        function downloadSelectedData() {
            if (recordedData.length === 0) { alert("저장할 데이터가 없습니다."); return; }
            let csvContent = "data:text/csv;charset=utf-8,\uFEFF";
            csvContent += "Timestamp,X,Y,Z\r\n";
            recordedData.forEach(rowArray => { csvContent += rowArray.join(",") + "\r\n"; });
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- 5. 새로운 충돌 시뮬레이션 로직 ---
        function startCollisionSimulation() {
            let frame = 0;
            const simDuration = 300; // 시뮬레이션 총 프레임 수
            const preCollisionFrames = 100; // 충돌 전 움직임 프레임
            const collisionFrames = 50;    // 충돌 순간 프레임
            const postCollisionFrames = simDuration - preCollisionFrames - collisionFrames; // 충돌 후 프레임
            
            let currentX = 0; // 자동차의 현재 X 위치 (애니메이션용)
            const carSpeed = 2; // 자동차 속도 (px/프레임)
            const wallX = simCar.parentElement.offsetWidth - simCar.offsetWidth - 10; // 벽 직전 위치

            simCar.style.transform = `translateX(0px)`;
            simExplosion.classList.remove('active');
            
            collisionSimulationInterval = setInterval(() => {
                frame++;
                let accX = 0, accY = 0, accZ = 9.8; // 기본 중력 가속도

                // 1. 충돌 전: 자동차가 벽으로 이동
                if (frame <= preCollisionFrames) {
                    accX = -0.5; // X축 방향으로 일정 가속도 (감속)
                    currentX += carSpeed;
                    if (currentX >= wallX) {
                        currentX = wallX; // 벽에 닿으면 멈춤
                    }
                    simCar.style.transform = `translateX(${currentX}px)`;
                }
                // 2. 충돌 순간: 가속도 급변
                else if (frame > preCollisionFrames && frame <= preCollisionFrames + collisionFrames) {
                    // 충돌 강도에 따른 가속도 변화 시뮬레이션
                    const collisionProgress = (frame - preCollisionFrames) / collisionFrames; // 0에서 1까지
                    accX = -200 * Math.sin(Math.PI * collisionProgress); // 순간적인 큰 음의 가속도 (충격)
                    accY = 10 * Math.sin(Math.PI * collisionProgress * 2); // Y, Z축도 약간의 흔들림
                    accZ = 9.8 + 5 * Math.sin(Math.PI * collisionProgress * 3);
                    
                    // 애니메이션: 충돌 이펙트 (폭발) 및 약간의 뒤로 밀림
                    if (collisionProgress > 0 && collisionProgress < 0.5) {
                        simExplosion.style.left = `${wallX - simCar.offsetWidth / 2}px`;
                        simExplosion.style.bottom = `${simCar.offsetHeight / 2}px`;
                        simExplosion.classList.add('active');
                        simCar.style.transform = `translateX(${currentX - 5 * collisionProgress}px)`; // 살짝 뒤로 밀림
                    } else if (collisionProgress >= 0.5) {
                        simExplosion.classList.remove('active');
                    }

                }
                // 3. 충돌 후: 가속도 안정화
                else if (frame > preCollisionFrames + collisionFrames && frame <= simDuration) {
                    accX = 0.1; // 약간의 반동 후 안정화
                    accY = 0.0;
                    accZ = 9.8;
                }
                // 4. 시뮬레이션 종료
                else {
                    clearInterval(collisionSimulationInterval);
                    statusSpan.textContent = "자동차 충돌 시뮬레이션 완료. 측정 시작 가능.";
                    collisionSimButton.disabled = false;
                    recordButton.disabled = false; // 시뮬레이션 끝나면 측정 시작 가능
                    simExplosion.classList.remove('active');
                    return;
                }

                // 가속도 데이터 전달 (녹화 중인 경우에만)
                if (isRecording) {
                    // X, Y, Z 데이터를 생성하여 onDataReceived로 전달
                    onDataReceived(accX, accY, accZ);
                }

            }, samplingIntervalMs); // samplingRateSelect의 값에 따라 데이터 생성 간격 조절
        }
    </script>
</body>
</html>
