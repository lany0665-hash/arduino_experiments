<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ê°€ì†ë„ê³„ ë°ì´í„° ë¶„ì„</title>
    <link rel="stylesheet" href="../css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/regression/2.0.1/regression.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
</head>
<body>
    <div class="container">
        <a href="../index.html">&laquo; ë©”ì¸ í˜ì´ì§€ë¡œ ëŒì•„ê°€ê¸°</a>
        <h1>ê°€ì†ë„ê³„ ë°ì´í„° ë¶„ì„</h1>
        <p>ìƒíƒœ: <span id="status">ì—°ê²° ëŒ€ê¸°</span></p>

        <div class="connection-section">
            <h3>ì—°ê²° ë°©ì‹ ì„ íƒ</h3>
            <button id="simulationButton" class="sim-button">1. ê°€ìƒ ì„¼ì„œë¡œ í…ŒìŠ¤íŠ¸</button>
            <hr>
            <button id="connectBleButton" class="ble-button">1. ì•„ë‘ì´ë…¸(BLE) ì—°ê²°</button>
        </div>

        <div class="button-group">
            <button id="recordButton" disabled>2. ì¸¡ì • ì‹œì‘</button>
            <select id="samplingRateSelect">
                <option value="10">10ms (100 Hz)</option>
                <option value="100">100ms (10 Hz)</option>
                <option value="500">500ms (2 Hz)</option>
                <option value="1000" selected>1s (1 Hz)</option>
                <option value="2000">2s (0.5 Hz)</option>
            </select>
            <button id="downloadButton" disabled>3. ì—‘ì…€ ì €ì¥</button>
        </div>
        
        <div class="main-layout">
            <div class="content-column">
                <h2>ì¸¡ì • ê¸°ë¡</h2>
                <div class="table-container">
                    <table id="historyTable">
                        <thead>
                            <tr>
                                <th>Timestamp</th><th>X</th><th>Y</th><th>Z</th>
                            </tr>
                        </thead>
                        <tbody id="historyTbody"></tbody>
                    </table>
                </div>
            </div>

            <div class="content-column">
                <h2>ê·¸ë˜í”„ ì‹œê°í™” ë° í•¨ìˆ˜ í”¼íŒ…</h2>
                <div class="graph-controls">
                    <span>Xì¶•:</span>
                    <select id="xAxisSelect"><option value="Index">ë°ì´í„° ìˆœì„œ (Index)</option><option value="X">X</option><option value="Y">Y</option><option value="Z">Z</option></select>
                    <span>Yì¶•:</span>
                    <select id="yAxisSelect"><option value="X">X</option><option value="Y">Y</option><option value="Z">Z</option></select>
                    <button id="resetZoomButton">ê·¸ë˜í”„ ì¤Œ ë¦¬ì…‹</button>
                </div>
                 <div class="graph-controls fit-controls">
                    <span>í”¼íŒ… ë²”ìœ„ (Xì¶• ë°ì´í„° ê¸°ì¤€):</span>
                    <input type="number" id="fitRangeStart" placeholder="ì‹œì‘">
                    <span>~</span>
                    <input type="number" id="fitRangeEnd" placeholder="ë">
                    <select id="polynomialOrderSelect">
                        <option value="1">1ì°¨</option><option value="2">2ì°¨</option><option value="3" selected>3ì°¨</option>
                    </select>
                    <button id="fitButton" disabled>í•¨ìˆ˜ í”¼íŒ…</button>
                </div>
                <div class="fit-result">
                    <p>í”¼íŒ… ë°©ì •ì‹: <span id="equation"></span></p>
                    <p><b>ê²°ì •ê³„ìˆ˜ (RÂ²): <span id="r2_value"></span></b></p>
                </div>
                <div class="chart-container"><canvas id="myChart"></canvas></div>
            </div>
        </div>
    </div>

    <script>
        // 1. UI ìš”ì†Œ ë° ì „ì—­ ë³€ìˆ˜ ì„ ì–¸
        const connectBleButton = document.getElementById('connectBleButton');
        const simulationButton = document.getElementById('simulationButton');
        const recordButton = document.getElementById('recordButton');
        const downloadButton = document.getElementById('downloadButton');
        const fitButton = document.getElementById('fitButton');
        const statusSpan = document.getElementById('status');
        const equationSpan = document.getElementById('equation');
        const r2ValueSpan = document.getElementById('r2_value');
        const historyTbody = document.getElementById('historyTbody');
        const xAxisSelect = document.getElementById('xAxisSelect');
        const yAxisSelect = document.getElementById('yAxisSelect');
        const samplingRateSelect = document.getElementById('samplingRateSelect');
        const resetZoomButton = document.getElementById('resetZoomButton');
        const chartCanvas = document.getElementById('myChart');
        const polynomialOrderSelect = document.getElementById('polynomialOrderSelect');
        const fitRangeStartInput = document.getElementById('fitRangeStart'); // ìƒˆë¡œ ì¶”ê°€
        const fitRangeEndInput = document.getElementById('fitRangeEnd');   // ìƒˆë¡œ ì¶”ê°€

        let recordedData = []; 
        let isRecording = false;
        let simulationInterval;
        let samplingIntervalMs = 1000;
        let lastSampleTime = 0;
        let myChart;
        let lastGraphUpdateTime = 0; // ì‹¤ì‹œê°„ ê·¸ë˜í”„ë¥¼ ìœ„í•œ ë³€ìˆ˜

        // 2. ì°¨íŠ¸ ì´ˆê¸°í™”
        myChart = new Chart(chartCanvas, {
            type: 'scatter',
            data: { datasets: [{ label: 'ì›ë³¸ ë°ì´í„°', data: [], backgroundColor: 'rgba(75, 192, 192, 0.6)', pointRadius: 3 }, { label: 'í•¨ìˆ˜ í”¼íŒ…', data: [], borderColor: 'rgba(255, 99, 132, 1)', type: 'line', fill: false, tension: 0.1, pointRadius: 0 }] },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'linear', title: { display: true, text: 'X-Axis' } }, y: { title: { display: true, text: 'Y-Axis' } } }, plugins: { zoom: { pan: { enabled: true, mode: 'xy' }, zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy' } } } }
        });

        // 3. ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì—°ê²°
        simulationButton.addEventListener('click', () => { statusSpan.textContent = "ê°€ìƒ ì„¼ì„œ ì—°ê²°ë¨"; connectBleButton.disabled = true; simulationButton.disabled = true; recordButton.disabled = false; let simCounter = 0; simulationInterval = setInterval(() => { const x = Math.sin(simCounter * 0.1) * 10 + Math.random(); const y = Math.cos(simCounter * 0.1) * 10 + Math.random(); const z = 5 + (Math.random() - 0.5) * 2; simCounter++; onDataReceived(x, y, z); }, 10); });
        connectBleButton.addEventListener('click', async () => { /* ì´ì „ê³¼ ë™ì¼ */ });
        samplingRateSelect.addEventListener('change', (event) => { samplingIntervalMs = parseInt(event.target.value); });
        
        recordButton.addEventListener('click', () => {
            isRecording = !isRecording;
            if (isRecording) {
                lastSampleTime = 0; recordedData = []; historyTbody.innerHTML = ''; 
                myChart.data.datasets[0].data = []; myChart.data.datasets[1].data = []; myChart.update(); // ê·¸ë˜í”„ ì´ˆê¸°í™”
                equationSpan.textContent = ''; r2ValueSpan.textContent = ''; 
                recordButton.textContent = 'ì¸¡ì • ì¤‘ì§€'; recordButton.style.backgroundColor = '#DC3545'; 
                downloadButton.disabled = true; fitButton.disabled = true; statusSpan.textContent = 'ì¸¡ì • ì¤‘...';
            } else {
                recordButton.textContent = 'ì¸¡ì • ì‹œì‘'; recordButton.style.backgroundColor = '#28A745'; statusSpan.textContent = 'ì¸¡ì • ì™„ë£Œ';
                if (recordedData.length > 0) { downloadButton.disabled = false; fitButton.disabled = false; }
            }
        });
        
        resetZoomButton.addEventListener('click', () => myChart.resetZoom());
        fitButton.addEventListener('click', fitPolynomialToRange);
        downloadButton.addEventListener('click', downloadSelectedData);
        // ì¶• ë³€ê²½ ì‹œ ê·¸ë˜í”„ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
        xAxisSelect.addEventListener('change', updateGraphAxes);
        yAxisSelect.addEventListener('change', updateGraphAxes);
        
        // --- ğŸ”» í•µì‹¬ ë³€ê²½ ì‚¬í•­ 2: í•¨ìˆ˜ ë¡œì§ ìˆ˜ì • ğŸ”» ---

        // 4. í•¨ìˆ˜ ì •ì˜
        function onDataReceived(x, y, z) { const now = Date.now(); if (now - lastSampleTime >= samplingIntervalMs) { lastSampleTime = now; processAndDisplayData(x, y, z); } }
        function handleBleNotifications(event) { /* ì´ì „ê³¼ ë™ì¼ */ }
        
        function processAndDisplayData(x, y, z) {
            if (isRecording) {
                const timestamp = new Date().toISOString();
                const currentData = [timestamp, parseFloat(x), parseFloat(y), parseFloat(z)];
                recordedData.push(currentData);
                
                // í…Œì´ë¸”ì— í–‰ ì¶”ê°€
                const newRow = historyTbody.insertRow(0); // ìƒˆ ë°ì´í„°ë¥¼ ë§¨ ìœ„ì— ì¶”ê°€
                newRow.innerHTML = `<td>${currentData[0]}</td><td>${currentData[1].toFixed(4)}</td><td>${currentData[2].toFixed(4)}</td><td>${currentData[3].toFixed(4)}</td>`;

                // ì‹¤ì‹œê°„ ê·¸ë˜í”„ ì—…ë°ì´íŠ¸
                updateGraphAxes(); // ì¶• ì„¤ì •ì— ë”°ë¼ ê·¸ë˜í”„ ì—…ë°ì´íŠ¸
            }
        }
        
        // ì¶•ì´ ë³€ê²½ë˜ê±°ë‚˜ ìƒˆ ë°ì´í„°ê°€ ë“¤ì–´ì˜¬ ë•Œ ê·¸ë˜í”„ë¥¼ ë‹¤ì‹œ ê·¸ë¦¬ëŠ” í•¨ìˆ˜
        function updateGraphAxes() {
            const colMap = { 'Index': -1, 'X': 1, 'Y': 2, 'Z': 3 }; // Timestamp ëŒ€ì‹  Index ì‚¬ìš©
            const xAxisColumn = xAxisSelect.value;
            const yAxisColumn = yAxisSelect.value;
            const xIndex = colMap[xAxisColumn];
            const yIndex = colMap[yAxisColumn];
            
            const scatterData = recordedData.map((row, i) => ({
                x: (xIndex === -1) ? i : row[xIndex],
                y: row[yIndex]
            }));

            myChart.data.datasets[0].data = scatterData;
            myChart.options.scales.x.title.text = xAxisColumn;
            myChart.options.scales.y.title.text = yAxisColumn;

            // ì„±ëŠ¥ì„ ìœ„í•´ 200ms ê°„ê²©ìœ¼ë¡œë§Œ ê·¸ë˜í”„ ì—…ë°ì´íŠ¸ ì‹¤í–‰
            const now = Date.now();
            if (now - lastGraphUpdateTime > 200) {
                myChart.update('none'); // ì• ë‹ˆë©”ì´ì…˜ ì—†ì´ ì—…ë°ì´íŠ¸
                lastGraphUpdateTime = now;
            }
        }

        function fitPolynomialToRange() {
            const order = parseInt(polynomialOrderSelect.value);
            const startX = parseFloat(fitRangeStartInput.value);
            const endX = parseFloat(fitRangeEndInput.value);

            if (isNaN(startX) || isNaN(endX) || startX >= endX) {
                alert("ìœ íš¨í•œ Xì¶• ì‹œì‘ê³¼ ë ë²”ìœ„ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
                return;
            }

            const colMap = { 'Index': -1, 'X': 1, 'Y': 2, 'Z': 3 };
            const xAxisColumn = xAxisSelect.value;
            const yAxisColumn = yAxisSelect.value;
            const xIndex = colMap[xAxisColumn];
            const yIndex = colMap[yAxisColumn];

            // ì…ë ¥ëœ Xì¶• ë²”ìœ„ì— í•´ë‹¹í•˜ëŠ” ë°ì´í„°ë§Œ í•„í„°ë§
            const dataForFitting = recordedData.map((row, i) => {
                const xValue = (xIndex === -1) ? i : row[xIndex];
                return [xValue, row[yIndex]];
            }).filter(point => point[0] >= startX && point[0] <= endX);

            if (dataForFitting.length < order + 1) {
                alert(`${order}ì°¨ í•¨ìˆ˜ í”¼íŒ…ì„ ìœ„í•´ì„œëŠ” ìµœì†Œ ${order + 1}ê°œì˜ ë°ì´í„°ê°€ ë²”ìœ„ ë‚´ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤. (í˜„ì¬ ${dataForFitting.length}ê°œ)`);
                return;
            }
            
            const result = regression.polynomial(dataForFitting, { order: order, precision: 5 });
            equationSpan.textContent = result.string;
            r2ValueSpan.textContent = result.r2.toFixed(4);
            const fittedPoints = result.points.map(p => ({x: p[0], y: p[1]}));
            myChart.data.datasets[1].data = fittedPoints;
            myChart.data.datasets[1].label = `${order}ì°¨ í”¼íŒ… (RÂ²=${result.r2.toFixed(4)})`;
            myChart.update();
        }

        function downloadSelectedData() {
            if (recordedData.length === 0) { alert("ì €ì¥í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."); return; }
            let csvContent = "data:text/csv;charset=utf-8,\uFEFF";
            csvContent += "Timestamp,X,Y,Z\r\n";
            recordedData.forEach(rowArray => { csvContent += rowArray.join(",") + "\r\n"; });
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "sensor_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>
</html>
